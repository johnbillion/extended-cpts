<?php
/*
Plugin Name:  Extended CPTs
Description:  Extended custom post types.
Version:      2.3.3
Plugin URI:   https://github.com/johnbillion/ExtendedCPTs
Author:       John Blackbourn
Author URI:   https://johnblackbourn.com
Text Domain:  extended-cpts
Domain Path:  /languages/
License:      GPL v2 or later

Copyright Â© 2014 John Blackbourn

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

*/

if ( !function_exists( 'register_extended_post_type' ) ) {
/**
 * Wrapper function for registering a new Extended Post Type.
 *
 * @see Extended_CPT::__construct()
 * @param string $post_type The post type name
 * @param array  $args      The post type arguments (optional)
 * @param array  $names     {
 *     An associative array of the plural, singular and slug names (optional)
 *
 *     @type string $plural   The plural form of the post type name
 *     @type string $slug     The slug used in the permalink for the post type
 *     @type string $singular The singular form of the post type name
 * }
 * @return Extended_CPT 
 */
if ( !function_exists( 'register_extended_post_type ') ) {
function register_extended_post_type( $post_type, array $args = null, $names = null ) {

	$fga = func_get_args();

	# Back-compat for pre-2.3 argument list:
	if ( is_string( $names ) or count( $fga ) > 3 ) {
		_doing_it_wrong( __FUNCTION__, __( 'Name parameters should be passed as an associative array.', 'extended-cpts' ), '2.3' );
		$names = array();
		if ( isset( $fga[2] ) )
			$names['plural'] = $fga[2];
		if ( isset( $fga[3] ) )
			$names['slug'] = $fga[3];
		if ( isset( $fga[4] ) )
			$names['singular'] = $fga[4];
	}

	$cpt = new Extended_CPT( $post_type, $args, $names );

	if ( is_admin() ) {
		new Extended_CPT_Admin( $cpt, $args );
	}

	return $cpt;

}
}

if ( !class_exists( 'Extended_CPT' ) ) {
class Extended_CPT {

	/**
	 * Default arguments for custom post types.
	 * Several of these differ from the defaults in WordPress' register_post_type() function.
	 *
	 * @var array
	 */
	protected $defaults = array(
		'public'               => true,
		'menu_position'        => 6,
		'menu_icon'            => null,
		'capability_type'      => 'page',
		'hierarchical'         => true,
		'supports'             => array( 'title', 'editor', 'thumbnail' ),
		'has_archive'          => true,
		'show_in_feed'         => false, # Custom arg
		'archive'              => null,  # Custom arg
	);

	/**
	 * Some other member variables you don't need to worry about:
	 */
	public $post_type;
	public $post_slug;
	public $post_singular;
	public $post_plural;
	public $post_singular_low;
	public $post_plural_low;
	public $args;
	protected $_cols;

	/**
	 * Class constructor.
	 *
	 * The $post_type parameter is used as the post type name and to build the post type labels. This
	 * means you can create a post type with just one parameter and all labels and post updated messages
	 * will be generated for you. Example:
	 *
	 * register_extended_post_type( 'event' );
	 *
	 * The plural name for a post type is generated by appending an 's' to $post_type. The post type slug
	 * is generated from the plural. The singular name is the same as the $post_type parameter. These can
	 * be overridden with the $names parameter if necessary. Example:
	 *
	 * register_extended_post_type( 'person', array(), array( 'plural' => 'people', 'slug' => meet-the-team' ) );
	 *
	 * The $args parameter accepts all the standard arguments for register_post_type() in addition to
	 * several custom arguments that provide extended functionality:
	 *
	 * - show_in_feed - boolean - Whether to include this post type in the site's main feed. Defaults to
	 * false.
	 *
	 * - archive - array - Associative array of query vars to override on this post type's archive.
	 * Handy for setting 'no_paging' to true, for example. Defaults to null (no overridden query vars).
	 *
	 * @param string $post_type The post type name
	 * @param array  $args      The post type arguments (optional)
	 * @param array  $names     An associative array of the plural, singular and slug names (optional)
	 */
	public function __construct( $post_type, array $args = null, array $names = null ) {

		if ( isset( $names['singular'] ) ) {
			$this->post_singular = $names['singular'];
		} else {
			$this->post_singular = ucwords( str_replace( array( '-', '_' ), ' ', $post_type ) );
		}

		if ( isset( $names['slug'] ) ) {
			$this->post_slug = $names['slug'];
		} else if ( isset( $names['plural'] ) ) {
			$this->post_slug = $names['plural'];
		} else {
			$this->post_slug = $post_type . 's';
		}

		if ( isset( $names['plural'] ) ) {
			$this->post_plural = $names['plural'];
		} else {
			$this->post_plural = $this->post_singular . 's';
		}

		$this->post_type = strtolower( $post_type );
		$this->post_slug = strtolower( $this->post_slug );

		# Build our base post type names:
		$this->post_singular_low = strtolower( $this->post_singular );
		$this->post_plural_low   = strtolower( $this->post_plural );

		# Build our labels:
		# Why aren't these translatable?
		# Answer: https://github.com/johnbillion/ExtendedCPTs/pull/5#issuecomment-33756474
		$this->defaults['labels'] = array(
			'name'               => $this->post_plural,
			'singular_name'      => $this->post_singular,
			'menu_name'          => $this->post_plural,
			'name_admin_bar'     => $this->post_singular,
			'add_new'            => 'Add New',
			'add_new_item'       => sprintf( 'Add New %s', $this->post_singular ),
			'edit_item'          => sprintf( 'Edit %s', $this->post_singular ),
			'new_item'           => sprintf( 'New %s', $this->post_singular ),
			'view_item'          => sprintf( 'View %s', $this->post_singular ),
			'search_items'       => sprintf( 'Search %s', $this->post_plural ),
			'not_found'          => sprintf( 'No %s found', $this->post_plural_low ),
			'not_found_in_trash' => sprintf( 'No %s found in trash', $this->post_plural_low ),
			'parent_item_colon'  => sprintf( 'Parent %s', $this->post_singular ),
			'all_items'          => sprintf( 'All %s', $this->post_plural ),
		);

		# Only set rewrites if we need them
		if ( isset( $args['public'] ) and !$args['public'] ) {
			$this->defaults['rewrite'] = false;
		} else {
			$this->defaults['rewrite'] = array(
				'slug'       => $this->post_slug,
				'with_front' => false
			);
		}

		# Merge our args with the defaults:
		$this->args = array_merge( $this->defaults, $args );

		# This allows the 'labels' arg to contain some, none or all labels:
		if ( isset( $args['labels'] ) ) {
			$this->args['labels'] = array_merge( $this->defaults['labels'], $args['labels'] );
		}

		# Post type in the site's main feed:
		if ( $this->args['show_in_feed'] ) {
			add_filter( 'request', array( $this, 'add_to_feed' ) );
		}

		# Post type archive query vars:
		if ( $this->args['archive'] and !is_admin() ) {
			add_filter( 'parse_request', array( $this, 'override_private_query_vars' ), 1 );
		}

		# Register post type when WordPress initialises:
		if ( 'init' === current_filter() ) {
			call_user_func( array( $this, 'register_post_type' ) );
		} else {
			add_action( 'init', array( $this, 'register_post_type' ), 9 );
		}

	}

	/**
	 * Add our post type to the feed.
	 *
	 * @param array $vars Request parameters
	 * @return array Updated request parameters
	 */
	public function add_to_feed( array $vars ) {

		# If it's not a feed, we're not interested:
		if ( !isset( $vars['feed'] ) ) {
			return $vars;
		}

		if ( !isset( $vars['post_type'] ) ) {
			$vars['post_type'] = array( 'post', $this->post_type );
		} else if ( is_array( $vars['post_type'] ) and ( count( $vars['post_type'] ) > 1 ) ) {
			$vars['post_type'][] = $this->post_type;
		}

		return $vars;

	}

	/**
	 * Add to or override our post type archive's private query vars.
	 *
	 * @param WP $wp The WP request object
	 * @return WP Updated WP request object
	 */
	public function override_private_query_vars( WP $wp ) {

		# If it's not our post type, bail out:
		if ( !isset( $wp->query_vars['post_type'] ) or ( $this->post_type != $wp->query_vars['post_type'] ) ) {
			return $wp;
		}

		# If it's a single post, bail out:
		if ( isset( $wp->query_vars['name'] ) ) {
			return $wp;
		}

		# Set the vars:
		foreach ( $this->args['archive'] as $var => $value ) {
			$wp->query_vars[$var] = $value;
		}

		return $wp;

	}

	/**
	 * Registers our post type.
	 *
	 * The only difference between this and regular register_post_type() calls is this will trigger
	 * an error of E_USER_ERROR level if a WP_Error is returned. Currently the only time you'll get
	 * an error from register_post_type() is if the post type name is too long.
	 *
	 * @return null
	 */
	public function register_post_type() {

		if ( ! isset( $this->args['query_var'] ) or ( true === $this->args['query_var'] ) ) {
			$query_var = $this->post_type;
		} else {
			$query_var = $this->args['query_var'];
		}

		$existing = get_post_type_object( $this->post_type );

		if ( $query_var and count( get_taxonomies( array( 'query_var' => $query_var ) ) ) ) {

			trigger_error( sprintf( __( 'Post type query var "%s" clashes with a taxonomy query var of the same name', 'extended-cpts' ), $query_var ), E_USER_ERROR );

		} else if ( empty( $existing ) ) {

			if ( is_wp_error( $cpt = register_post_type( $this->post_type, $this->args ) ) ) {
				trigger_error( $cpt->get_error_message(), E_USER_ERROR );
			}

		} else {

			# This allows us to call register_extended_post_type() on an existing post type to add custom functionality to it

			$this->extend( $existing );

		}

	}

	/**
	 * Extends an existing post type object. Currently only handles labels.
	 *
	 * @param object $pto A post type object
	 * @return null
	 */
	public function extend( $pto ) {
		$GLOBALS['wp_post_types'][$pto->name]->labels = (object) $this->args['labels'];
	}

	/**
	 * Helper function for registering a taxonomy and adding it to this post type. Accepts the same
	 * parameters as register_extended_taxonomy(), minus the $object_type parameter. Will fall back
	 * to register_taxonomy() if Extended Taxonomies isn't present.
	 *
	 * Example usage:
	 *
	 * $events   = register_extended_post_type( 'event' );
	 * $location = $events->add_taxonomy( 'location' );
	 *
	 * @param string $taxonomy The taxonomy name
	 * @param array  $args     The taxonomy arguments (optional)
	 * @param array  $names    An associative array of the plural, singular and slug names (optional)
	 * @return object Taxonomy object
	 */
	public function add_taxonomy( $taxonomy, array $args = null, $names = null ) {

		$fga = func_get_args();

		# Back-compat for pre-2.3 argument list:
		if ( is_string( $names ) or count( $fga ) > 3 ) {
			_doing_it_wrong( __FUNCTION__, __( 'Name parameters should be passed as an associative array.', 'extended-cpts' ), '2.3' );
			$names = array();
			if ( isset( $fga[2] ) )
				$names['plural'] = $fga[2];
			if ( isset( $fga[3] ) )
				$names['slug'] = $fga[3];
			if ( isset( $fga[4] ) )
				$names['singular'] = $fga[4];
		}

		if ( taxonomy_exists( $taxonomy ) ) {
			register_taxonomy_for_object_type( $taxonomy, $this->post_type );
		} else if ( function_exists( 'register_extended_taxonomy' ) ) {
			register_extended_taxonomy( $taxonomy, $this->post_type, $args, $names );
		} else {
			register_taxonomy( $taxonomy, $this->post_type, $args );
		}

		return get_taxonomy( $taxonomy );

	}

}
}

if ( !class_exists( 'Extended_CPT_Admin' ) ) {
class Extended_CPT_Admin {

	/**
	 * Default arguments for custom post types.
	 *
	 * @var array
	 */
	protected $defaults = array(
		'archive_in_nav_menus' => true,  # Custom arg
		'quick_edit'           => true,  # Custom arg
		'right_now'            => true,  # Custom arg
		'cols'                 => null,  # Custom arg
		'filters'              => null,  # Custom arg
		'enter_title_here'     => null,  # Custom arg
		'featured_image'       => null,  # Custom arg
	);
	public $cpt;
	public $args;
	protected static $current_post_type;

	/**
	 * Class constructor.
	 *
	 * The $args parameter accepts the following arguments:
	 *
	 * - archive_in_nav_menus - boolean - Whether to show an 'All Items' checkbox for this post type on
	 * the nav menus screen so the post type archive can easily be added to a nav menu without manually
	 * adding a custom link. Uses the 'all_items' label for the nav menus screen checkbox and the 'name'
	 * label for the actual menu item. Defaults to true.
	 *
	 * - quick_edit - boolean - Whether to show Quick Edit links for this post type. Defaults to true.
	 *
	 * - right_now - boolean - Whether to show this post type on the 'Right Now' section of WordPress'
	 * dashboard. Defaults to true.
	 *
	 * - cols - array - Associative array of admin columns to show for this post type. See the cols()
	 * method of this class for more information. Defaults to null (no custom columns).
	 *
	 * - filters - array - Associative array of admin filters to show for this post type. See the
	 * filters() method of this class for more information. Defaults to null (no custom filters).
	 *
	 * - enter_title_here - string - Placeholder text which appears in the title field for this post type.
	 *
	 * - featured_image - string - Text which replaces 'Featured Image' for this post type.
	 *
	 * @param Extended_CPT $cpt  An extended post type object
	 * @param array        $args The admin arguments (optional)
	 */
	public function __construct( Extended_CPT $cpt, array $args = null ) {

		$this->cpt = $cpt;
		# Merge our args with the defaults:
		$this->args = wp_parse_args( $args, $this->defaults );

		# Admin columns:
		if ( $this->args['cols'] ) {
			add_filter( 'manage_posts_columns',                                 array( $this, '_log_default_cols' ), 0 );
			add_filter( 'manage_pages_columns',                                 array( $this, '_log_default_cols' ), 0 );
			add_filter( "manage_edit-{$this->cpt->post_type}_sortable_columns", array( $this, 'sortables' ) );
			add_filter( "manage_{$this->cpt->post_type}_posts_columns",         array( $this, 'cols' ) );
			add_action( "manage_{$this->cpt->post_type}_posts_custom_column",   array( $this, 'col' ) );
			add_action( 'load-edit.php',                                        array( $this, 'default_sort' ) );
			add_action( 'load-edit.php',                                        array( $this, 'maybe_sort' ) );
		}

		# Admin filters:
		if ( $this->args['filters'] ) {
			add_action( 'load-edit.php', array( $this, 'maybe_filter' ) );
			add_filter( 'query_vars',    array( $this, 'add_filter_query_vars' ) );
		}

		# 'Enter title here' filter:
		if ( $this->args['enter_title_here'] ) {
			add_filter( 'enter_title_here', array( $this, 'enter_title_here' ), 10, 2 );
		}

		# Featured Image title:
		if ( $this->args['featured_image'] ) {
			add_filter( 'gettext', array( $this, 'featured_image_text' ) );
		}

		# Hide month filter:
		if ( isset( $this->args['filters']['m'] ) and !$this->args['filters']['m'] ) {
			add_action( 'admin_head-edit.php', array( $this, 'admin_head' ) );
		}

		# Quick Edit:
		if ( !$this->args['quick_edit'] ) {
			add_filter( 'post_row_actions',                          array( $this, 'remove_quick_edit_action' ) );
			add_filter( 'page_row_actions',                          array( $this, 'remove_quick_edit_action' ) );
			add_filter( "bulk_actions-edit-{$this->cpt->post_type}", array( $this, 'remove_quick_edit_menu' ) );
		}

		# 'Right Now' / 'At a Glance' dashboard panels:
		if ( $this->args['right_now'] ) {
			add_action( 'right_now_content_table_end', array( $this, 'right_now' ), $this->cpt->args['menu_position'] );
			add_filter( 'dashboard_glance_items',      array( $this, 'glance_items' ), $this->cpt->args['menu_position'] );
		}

		# Nav menus screen item:
		if ( $this->args['archive_in_nav_menus'] and $this->cpt->args['has_archive'] ) {
			add_filter( "nav_menu_items_{$this->cpt->post_type}", array( $this, 'nav_menu_items' ), 10, 3 );
		}

		# Post updated messages:
		add_filter( 'post_updated_messages',      array( $this, 'post_updated_messages' ), 1 );
		add_filter( 'bulk_post_updated_messages', array( $this, 'bulk_post_updated_messages' ), 1, 2 );

	}

	/**
	 * Add some CSS to the post edit screen. Used to hide various screen elements.
	 *
	 * @return null
	 */
	public function admin_head() {

		if ( $this->cpt->post_type != self::get_current_post_type() ) {
			return;
		}

		?>
		<style type="text/css">
		<?php if ( isset( $this->args['filters']['m'] ) and !$this->args['filters']['m'] ) { ?>
			#posts-filter select[name="m"] {
				display: none;
			}
		<?php } ?>
		</style>
		<?php

	}

	/**
	 * Set the default sort field and sort order on our post type admin screen.
	 *
	 * @return null
	 */
	public function default_sort() {

		if ( $this->cpt->post_type != self::get_current_post_type() ) {
			return;
		}

		# If we've already ordered the screen, bail out:
		if ( isset( $_GET['orderby'] ) ) {
			return;
		}

		# Loop over our columns to find the default sort column (if there is one):
		foreach ( $this->args['cols'] as $id => $col ) {
			if ( is_array( $col ) and isset( $col['default'] ) ) {
				$_GET['orderby'] = $id;
				$_GET['order']   = ( 'desc' == strtolower( $col['default'] ) ? 'desc' : 'asc' );
				break;
			}
		}

	}

	/**
	 * Add the relevant filters for sorting posts by our sortable fields.
	 *
	 * @return null
	 */
	public function maybe_sort() {

		if ( $this->cpt->post_type != self::get_current_post_type() ) {
			return;
		}

		add_filter( 'request',       array( $this, 'sort_posts_by_post_meta' ) );
		add_filter( 'request',       array( $this, 'sort_posts_by_post_field' ) );
		add_filter( 'posts_clauses', array( $this, 'sort_posts_by_taxonomy' ), 10, 2 );

	}

	/**
	 * Add the relevant filters for filtering posts by our custom filters.
	 *
	 * @return null
	 */
	public function maybe_filter() {

		if ( $this->cpt->post_type != self::get_current_post_type() ) {
			return;
		}

		add_filter( 'request',               array( $this, 'filter_posts_by_post_meta' ) );
		add_action( 'restrict_manage_posts', array( $this, 'filters' ) );

	}

	/**
	 * Set the placeholder text for the title field for this post type.
	 *
	 * @param string  $title The placeholder text
	 * @param WP_Post $post  The current post
	 * @return string The updated placeholder text
	 */
	public function enter_title_here( $title, WP_Post $post ) {

		if ( $this->cpt->post_type != $post->post_type ) {
			return $title;
		}

		return $this->args['enter_title_here'];

	}

	/**
	 * Set the "featured image" text for this post type.
	 *
	 * See http://core.trac.wordpress.org/ticket/19257
	 *
	 * @param string $text The "featured image" text
	 * @return string The updated "featured image" text
	 */
	function featured_image_text( $text ) {

		if ( false === stripos( $text, 'featured image' ) ) {
			return $text;
		}

		if ( $this->cpt->post_type != self::get_current_post_type() ) {
			return $text;
		}

		$text = str_replace( 'featured image', strtolower( $this->args['featured_image'] ), $text );
		$text = str_replace( 'Featured Image', $this->args['featured_image'], $text );

		return $text;

	}

	/**
	 * Returns the name of the post type for the current request.
	 *
	 * @return string The post type name
	 */
	protected static function get_current_post_type() {

		if ( isset( self::$current_post_type ) ) {
			return self::$current_post_type;
		}

		if ( function_exists( 'get_current_screen' ) and is_object( get_current_screen() ) ) {
			$post_type = get_current_screen()->post_type;
		} else {
			$post_type = '';
		}

		if ( empty( $post_type ) ) {
			if ( isset( $_REQUEST['post_type'] ) ) {
				$post_type = $_REQUEST['post_type'];
			} else if ( isset( $_REQUEST['post'] ) ) {
				$post_type = get_post_type( $_REQUEST['post'] );
			} else if ( isset( $_REQUEST['post_id'] ) ) {
				$post_type = get_post_type( $_REQUEST['post_id'] );
			} else if ( isset( $_REQUEST['attachment_id'] ) ) {
				$post_type = get_post_type( get_post( $_REQUEST['attachment_id'] )->post_parent );
			}
		}

		return self::$current_post_type = $post_type;

	}

	/**
	 * Output custom filter dropdown menus on the admin screen for this post type.
	 *
	 * Each item in the 'filters' array is an associative array of information for a filter. Defining a
	 * filter is easy. Just define an array which includes the filter title and filter type. You can
	 * display filters for post meta fields and taxonomy terms.
	 *
	 * The example below adds filters for the 'event_type' meta key and the 'location' taxonomy:
	 *
	 * register_extended_post_type( 'event', array(
	 *     'filters' => array(
	 *         'event_type' => array(
	 *             'title'    => 'Event Type',
	 *             'meta_key' => 'event_type'
	 *         ),
	 *         'event_location' => array(
	 *             'title'    => 'Location',
	 *             'taxonomy' => 'location'
	 *         ),
	 *         'event_is' => array(
	 *             'title'       => 'All Events',
	 *             'meta_exists' => array(
	 *                 'event_featured'  => 'Featured Events',
	 *                 'event_cancelled' => 'Cancelled Events'
	 *             )
	 *         ),
	 *     )
	 * ) );
	 *
	 * That's all you need to do. WordPress handles taxonomy term filtering itself (the plugin just
	 * outputs the dropdown), and the plugin handles the dropdown menu and filtering for post meta.
	 *
	 * Each item in the 'filters' array needs either a 'taxonomy', 'meta_key' or 'meta_exists' element
	 * containing the corresponding taxonomy name or post meta key.
	 *
	 * The 'meta_exists' filter outputs a dropdown menu listing each of the meta_exists fields,
	 * allowing users to filter the screen by posts which have the corresponding meta field.
	 *
	 * There are a couple of optional elements:
	 *
	 * - title - The filter title. If omitted, the title will use the all_items taxonomy label or a
	 * formatted version of the post meta key.
	 *
	 * - cap - A capability required in order for this filter to be displayed to the current user. Defaults
	 * to null, meaning the filter is shown to all users.
	 *
	 * @return null
	 */
	public function filters() {

		global $wpdb;

		$pto = get_post_type_object( $this->cpt->post_type );

		foreach ( $this->args['filters'] as $filter_key => $filter ) {

			if ( isset( $filter['cap'] ) and !current_user_can( $filter['cap'] ) ) {
				continue;
			}

			if ( isset( $filter['taxonomy'] ) ) {

				$tax = get_taxonomy( $filter['taxonomy'] );

				if ( empty( $tax ) ) {
					continue;
				}

				# For this, we need the dropdown walker from Extended Taxonomies:
				if ( !class_exists( $class = 'Walker_ExtendedTaxonomyDropdown' ) ) {
					trigger_error( sprintf( __( 'The %s class is required in order to display taxonomy filters', 'extended-cpts' ), $class ), E_USER_WARNING );
					continue;
				} else {
					$walker = new Walker_ExtendedTaxonomyDropdown( array(
						'field' => 'slug'
					) );
				}

				# If we haven't specified a title, use the all_items label from the taxonomy:
				if ( !isset( $filter['title'] ) ) {
					$filter['title'] = $tax->labels->all_items;
				}

				# Output the dropdown:
				wp_dropdown_categories( array(
					'show_option_all' => $filter['title'] . '&nbsp;',
					'hide_empty'      => false,
					'hide_if_empty'   => true,
					'hierarchical'    => true,
					'show_count'      => false,
					'orderby'         => 'name',
					'selected_cats'   => get_query_var( $tax->query_var ),
					'id'              => 'filter_' . $filter_key,
					'name'            => $tax->query_var,
					'taxonomy'        => $filter['taxonomy'],
					'walker'          => $walker
				) );

			} else if ( isset( $filter['meta_key'] ) ) {

				# If we haven't specified a title, generate one from the meta key:
				if ( !isset( $filter['title'] ) ) {
					$filter['title'] = str_replace( array( '-', '_' ), ' ', $filter['meta_key'] );
					$filter['title'] = ucwords( $filter['title'] ) . 's';
					$filter['title'] = sprintf( __( 'All %s', 'extended-cpts' ), $filter['title'] );
				}

				if ( !isset( $filter['options'] ) ) {
					# Fetch all the values for our meta key:
					$filter['options'] = $wpdb->get_col( $wpdb->prepare( "
						SELECT DISTINCT meta_value
						FROM {$wpdb->postmeta} as m
						JOIN {$wpdb->posts} as p ON ( p.ID = m.post_id )
						WHERE m.meta_key = %s
						AND m.meta_value != ''
						AND p.post_type = %s
						ORDER BY m.meta_value ASC
					", $filter['meta_key'], $this->cpt->post_type ) );
				} else if ( is_callable( $filter['options'] ) ) {
					$filter['options'] = call_user_func( $filter['options'] );
				}

				if ( empty( $filter['options'] ) ) {
					continue;
				}

				$selected = stripslashes( get_query_var( $filter_key ) );

				# Output the dropdown:
				?>
				<select name="<?php echo esc_attr( $filter_key ); ?>" id="filter_<?php echo esc_attr( $filter_key ); ?>">
					<option value=""><?php echo esc_html( $filter['title'] ); ?>&nbsp;</option>
					<?php foreach ( $filter['options'] as $v ) { ?>
						<option value="<?php echo esc_attr( $v ); ?>" <?php selected( $selected, $v ); ?>><?php echo esc_html( $v ); ?></option>
					<?php } ?>
				</select>
				<?php

			} else if ( isset( $filter['meta_search_key'] ) ) {

				# If we haven't specified a title, generate one from the meta key:
				if ( !isset( $filter['title'] ) ) {
					$filter['title'] = str_replace( array( '-', '_' ), ' ', $filter['meta_search_key'] );
					$filter['title'] = ucwords( $filter['title'] );
				}

				$value = stripslashes( get_query_var( $filter_key ) );

				# Output the search box:
				?>
				<label><?php printf( '%s:', esc_html( $filter['title'] ) ); ?>&nbsp;<input type="text" name="<?php echo esc_attr( $filter_key ); ?>" id="filter_<?php echo esc_attr( $filter_key ); ?>" value="<?php echo esc_attr( $value ); ?>" /></label>
				<?php

			} else if ( isset( $filter['meta_exists'] ) ) {

				# If we haven't specified a title, use the all_items label from the post type:
				if ( !isset( $filter['title'] ) ) {
					$filter['title'] = $pto->labels->all_items;
				}

				$selected = stripslashes( get_query_var( $filter_key ) );

				if ( 1 == count( $filter['meta_exists'] ) ) {

					# Output a checkbox:
					foreach ( $filter['meta_exists'] as $v => $t ) {
						?>
						<label><input type="checkbox" name="<?php echo esc_attr( $filter_key ); ?>" id="filter_<?php echo esc_attr( $filter_key ); ?>" value="<?php echo esc_attr( $v ); ?>" <?php checked( $selected, $v ); ?>>&nbsp;<?php echo esc_html( $t ); ?></label>
						<?php
					}

				} else {

					# Output a dropdown:
					?>
					<select name="<?php echo esc_attr( $filter_key ); ?>" id="filter_<?php echo esc_attr( $filter_key ); ?>">
						<option value=""><?php echo esc_html( $filter['title'] ); ?>&nbsp;</option>
						<?php foreach ( $filter['meta_exists'] as $v => $t ) { ?>
							<option value="<?php echo esc_attr( $v ); ?>" <?php selected( $selected, $v ); ?>><?php echo esc_html( $t ); ?></option>
						<?php } ?>
					</select>
					<?php

				}

			}

		}

	}

	/**
	 * Add our post meta filter names to the public query vars.
	 *
	 * @param array $vars Public query variables
	 * @return array Updated public query variables
	 */
	public function add_filter_query_vars( array $vars ) {

		foreach ( $this->args['filters'] as $filter_key => $filter ) {
			if ( isset( $filter['meta_key'] ) or isset( $filter['meta_search_key'] ) or isset( $filter['meta_exists'] ) ) {
				$vars[] = $filter_key;
			}
		}

		return $vars;

	}

	/**
	 * Add our post meta filters to the request parameters.
	 *
	 * @param array $vars Request parameters
	 * @return array Updated request parameters
	 */
	public function filter_posts_by_post_meta( array $vars ) {

		foreach ( $this->args['filters'] as $filter_key => $filter ) {

			if ( isset( $filter['cap'] ) and !current_user_can( $filter['cap'] ) ) {
				continue;
			}

			if ( isset( $filter['meta_key'] ) and isset( $vars[$filter_key] ) and !empty( $vars[$filter_key] ) ) {
				$args = array(
					'key'   => $filter['meta_key'],
					'value' => stripslashes( $vars[$filter_key] )
				);
				if ( isset( $filter['meta_compare'] ) ) {
					$args['compare'] = $filter['meta_compare'];
				}
				$vars['meta_query'][] = $args;
			} else if ( isset( $filter['meta_search_key'] ) and isset( $vars[$filter_key] ) and !empty( $vars[$filter_key] ) ) {
				# @TODO kill the meta_search_key parameter and user meta_key with some complimentary parameters
				$vars['meta_query'][] = array(
					'key'     => $filter['meta_search_key'],
					'value'   => stripslashes( $vars[$filter_key] ),
					'compare' => 'LIKE'
				);
			} else if ( isset( $filter['meta_exists'] ) and isset( $vars[$filter_key] ) and !empty( $vars[$filter_key] ) ) {
				$args = array(
					'key'     => stripslashes( $vars[$filter_key] ),
				);
				if ( isset( $filter['meta_value'] ) ) {
					$args['value'] = $filter['meta_value'];
					if ( isset( $filter['meta_compare'] ) )
						$args['compare'] = $filter['meta_compare'];
				} else {
					$args['compare'] = 'NOT IN';
					$args['value']   = array( '', '0', 'false', 'null' );
				}
				$vars['meta_query'][] = $args;
			}

		}

		return $vars;

	}

	/**
	 * Add our post type to the 'Right Now' widget on the WordPress (<3.8) dashboard.
	 *
	 * @return null
	 */
	public function right_now() {

		$pto = get_post_type_object( $this->cpt->post_type );

		if ( !current_user_can( $pto->cap->edit_posts ) ) {
			return;
		}

		# Get the labels and format the counts:
		$count = wp_count_posts( $this->cpt->post_type );
		$text  = self::n( $pto->labels->singular_name, $pto->labels->name, $count->publish );
		$num   = number_format_i18n( $count->publish );

		# Add edit links:
		$num  = '<a href="edit.php?post_type=' . $this->cpt->post_type . '">' . $num . '</a>';
		$text = '<a href="edit.php?post_type=' . $this->cpt->post_type . '">' . $text . '</a>';

		# Output it:
		echo '<tr>';
		echo '<td class="first b b-' . $this->cpt->post_type . '">' . $num . '</td>';
		echo '<td class="t ' . $this->cpt->post_type . '">' . $text . '</td>';
		echo '</tr>';

	}

	/**
	 * Add our post type to the 'At a Glance' widget on the WordPress 3.8+ dashboard.
	 *
	 * @param array $items Array of items to display on the widget
	 * @return array Updated array of items
	 */
	public function glance_items( array $items ) {

		$pto = get_post_type_object( $this->cpt->post_type );

		if ( !current_user_can( $pto->cap->edit_posts ) ) {
			return $items;
		}

		# Get the labels and format the counts:
		$count = wp_count_posts( $this->cpt->post_type );
		$text  = self::n( $pto->labels->singular_name, $pto->labels->name, $count->publish );
		$num   = number_format_i18n( $count->publish );

		# This is absolutely not localisable. WordPress 3.8 didn't add a new post type label.
		$text = '<a href="edit.php?post_type=' . $this->cpt->post_type . '">' . $num . ' ' . $text . '</a>';

		# Go!
		$items[] = $text;

		return $items;

	}

	/**
	 * Add our post type updated messages.
	 *
	 * The messages are as follows:
	 *
	 *   1 => "Post updated. {View Post}"
	 *   2 => "Custom field updated."
	 *   3 => "Custom field deleted."
	 *   4 => "Post updated."
	 *   5 => "Post restored to revision from [date]."
	 *   6 => "Post published. {View post}"
	 *   7 => "Post saved."
	 *   8 => "Post submitted. {Preview post}"
	 *   9 => "Post scheduled for: [date]. {Preview post}"
	 *  10 => "Post draft updated. {Preview post}"
	 *
	 * @param array $messages An associative array of post updated messages with post type as keys.
	 * @return array Updated array of post updated messages.
	 */
	public function post_updated_messages( array $messages ) {

		global $post;

		$pto = get_post_type_object( $this->cpt->post_type );

		$messages[$this->cpt->post_type] = array(
			1 => sprintf( ( $pto->publicly_queryable ? '%1$s updated. <a href="%2$s">View %3$s</a>' : '%1$s updated.' ),
				$this->cpt->post_singular,
				esc_url( get_permalink( $post->ID ) ),
				$this->cpt->post_singular_low
			),
			2 => 'Custom field updated.',
			3 => 'Custom field deleted.',
			4 => sprintf( '%s updated.',
				$this->cpt->post_singular
			),
			5 => isset( $_GET['revision'] ) ? sprintf( '%1$s restored to revision from %2$s',
				$this->cpt->post_singular,
				wp_post_revision_title( intval( $_GET['revision'] ), false )
			) : false,
			6 => sprintf( ( $pto->publicly_queryable ? '%1$s published. <a href="%2$s">View %3$s</a>' : '%1$s published.' ),
				$this->cpt->post_singular,
				esc_url( get_permalink( $post->ID ) ),
				$this->cpt->post_singular_low
			),
			7 => sprintf( '%s saved.',
				$this->cpt->post_singular
			),
			8 => sprintf( ( $pto->publicly_queryable ? '%1$s submitted. <a target="_blank" href="%2$s">Preview %3$s</a>' : '%1$s submitted.' ),
				$this->cpt->post_singular,
				esc_url( add_query_arg( 'preview', 'true', get_permalink( $post->ID ) ) ),
				$this->cpt->post_singular_low
			),
			9 => sprintf( ( $pto->publicly_queryable ? '%1$s scheduled for: <strong>%2$s</strong>. <a target="_blank" href="%3$s">Preview %4$s</a>' : '%1$s scheduled for: <strong>%2$s</strong>.' ),
				$this->cpt->post_singular,
				date_i18n( 'M j, Y @ G:i', strtotime( $post->post_date ) ),
				esc_url( get_permalink( $post->ID ) ),
				$this->cpt->post_singular_low
			),
			10 => sprintf( ( $pto->publicly_queryable ? '%1$s draft updated. <a target="_blank" href="%2$s">Preview %3$s</a>' : '%1$s draft updated.' ),
				$this->cpt->post_singular,
				esc_url( add_query_arg( 'preview', 'true', get_permalink( $post->ID ) ) ),
				$this->cpt->post_singular_low
			),
		);

		return $messages;

	}

	/**
	 * Add our bulk post type updated messages.
	 *
	 * The messages are as follows:
	 *
	 *   updated   => "Post updated." | "[n] posts updated."
	 *   locked    => "Post not updated, somebody is editing it." | "[n] posts not updated, somebody is editing them."
	 *   deleted   => "Post permanently deleted." | "[n] posts permanently deleted."
	 *   trashed   => "Post moved to the trash." | "[n] posts moved to the trash."
	 *   untrashed => "Post restored from the trash." | "[n] posts restored from the trash."
	 *
	 * @param array $messages An associative array of bulk post updated messages with post type as keys.
	 * @param array $counts   An array of counts for each key in $messages.
	 * @return array Updated array of bulk post updated messages.
	 */
	public function bulk_post_updated_messages( array $messages, array $counts ) {

		$messages[$this->cpt->post_type] = array(
			'updated' => sprintf( self::n( '%2$s updated.', '%1$s %3$s updated.', $counts['updated'] ),
				number_format_i18n( $counts['updated'] ),
				$this->cpt->post_singular,
				$this->cpt->post_plural_low
			),
			'locked' => sprintf( self::n( '%2$s not updated, somebody is editing it.', '%1$s %3$s not updated, somebody is editing them.', $counts['locked'] ),
				number_format_i18n( $counts['locked'] ),
				$this->cpt->post_singular,
				$this->cpt->post_plural_low
			),
			'deleted' => sprintf( self::n( '%2$s permanently deleted.', '%1$s %3$s permanently deleted.', $counts['deleted'] ),
				number_format_i18n( $counts['deleted'] ),
				$this->cpt->post_singular,
				$this->cpt->post_plural_low
			),
			'trashed' => sprintf( self::n( '%2$s moved to the trash.', '%1$s %3$s moved to the trash.', $counts['trashed'] ),
				number_format_i18n( $counts['trashed'] ),
				$this->cpt->post_singular,
				$this->cpt->post_plural_low
			),
			'untrashed' => sprintf( self::n( '%2$s restored from the trash.', '%1$s %3$s restored from the trash.', $counts['untrashed'] ),
				number_format_i18n( $counts['untrashed'] ),
				$this->cpt->post_singular,
				$this->cpt->post_plural_low
			),
		);

		return $messages;

	}

	/**
	 * Sort posts by post meta value.
	 *
	 * @param array $vars Request parameters
	 * @return array Updated request parameters
	 */
	public function sort_posts_by_post_meta( array $vars ) {

		if ( !isset( $vars['orderby'] ) ) {
			return $vars;
		}
		if ( !isset( $this->args['cols'][$vars['orderby']] ) ) {
			return $vars;
		}
		if ( !is_array( $this->args['cols'][$vars['orderby']] ) ) {
			return $vars;
		}
		if ( !isset( $this->args['cols'][$vars['orderby']]['meta_key'] ) ) {
			return $vars;
		}

		$vars['meta_key'] = $this->args['cols'][$vars['orderby']]['meta_key'];
		$vars['orderby']  = 'meta_value';

		return $vars;

	}

	/**
	 * Sort posts by post field.
	 *
	 * @param array $vars Request parameters
	 * @return array Updated request parameters
	 */
	public function sort_posts_by_post_field( array $vars ) {

		if ( !isset( $vars['orderby'] ) ) {
			return $vars;
		}
		if ( !isset( $this->args['cols'][$vars['orderby']] ) ) {
			return $vars;
		}
		if ( !is_array( $this->args['cols'][$vars['orderby']] ) ) {
			return $vars;
		}
		if ( !isset( $this->args['cols'][$vars['orderby']]['post_field'] ) ) {
			return $vars;
		}

		$field = str_replace( 'post_', '', $this->args['cols'][$vars['orderby']]['post_field'] );
		$vars['orderby'] = $field;

		return $vars;

	}

	/**
	 * Sort posts by taxonomy term(s).
	 *
	 * @param array    $clauses Request SQL clauses
	 * @param WP_Query $q       The request's WP_Query object
	 * @return array Updated request SQL clauses
	 */
	public function sort_posts_by_taxonomy( array $clauses, WP_Query $q ) {

		global $wpdb;

		if ( !isset( $q->query['orderby'] ) ) {
			return $clauses;
		}
		if ( !isset( $this->args['cols'][$q->query['orderby']] ) ) {
			return $clauses;
		}
		if ( !is_array( $this->args['cols'][$q->query['orderby']] ) ) {
			return $clauses;
		}
		if ( !isset( $this->args['cols'][$q->query['orderby']]['taxonomy'] ) ) {
			return $clauses;
		}

		# Taxonomy term ordering courtesy of http://scribu.net/wordpress/sortable-taxonomy-columns.html

		$clauses['join'] .= "
			LEFT OUTER JOIN {$wpdb->term_relationships} as ext_cpts_tr ON ( {$wpdb->posts}.ID = ext_cpts_tr.object_id )
			LEFT OUTER JOIN {$wpdb->term_taxonomy} as ext_cpts_tt ON ( ext_cpts_tr.term_taxonomy_id = ext_cpts_tt.term_taxonomy_id )
			LEFT OUTER JOIN {$wpdb->terms} as ext_cpts_t ON ( ext_cpts_tt.term_id = ext_cpts_t.term_id )
		";
		$clauses['where'] .= $wpdb->prepare( " AND ( taxonomy = %s OR taxonomy IS NULL )", $this->args['cols'][$q->query['orderby']]['taxonomy'] );
		$clauses['groupby'] = 'ext_cpts_tr.object_id';
		$clauses['orderby'] = "GROUP_CONCAT( ext_cpts_t.name ORDER BY name ASC ) ";
		$clauses['orderby'] .= ( 'ASC' == strtoupper( $q->get('order') ) ) ? 'ASC' : 'DESC';

		return $clauses;

	}

	/**
	 * Add our custom columns to the list of sortable columns.
	 *
	 * @param array $cols Associative array of sortable columns
	 * @return array Updated array of sortable columns
	 */
	public function sortables( array $cols ) {

		foreach ( $this->args['cols'] as $id => $col ) {
			if ( !is_array( $col ) ) {
				continue;
			}
			if ( isset( $col['sortable'] ) and !$col['sortable'] ) {
				continue;
			}
			if ( isset( $col['meta_key'] ) or isset( $col['taxonomy'] ) or isset( $col['post_field'] ) ) {
				$cols[$id] = $id;
			}
		}

		return $cols;

	}

	/**
	 * Add columns to the admin screen for this post type.
	 *
	 * Each item in the 'cols' array is either a string name of an existing column, or an associative
	 * array of information for a custom column.
	 *
	 * Defining a custom column is easy. Just define an array which includes the column title, column
	 * type, and optional callback function. You can display columns for post meta, taxonomy terms,
	 * post fields, the featured image, and custom functions.
	 *
	 * The example below adds two columns; one which displays the value of the post's 'event_type' meta
	 * key and one which lists the post's terms from the 'location' taxonomy:
	 *
	 * register_extended_post_type( 'event', array(
	 *     'cols' => array(
	 *         'event_type' => array(
	 *             'title'    => 'Event Type',
	 *             'meta_key' => 'event_type'
	 *         ),
	 *         'event_location' => array(
	 *             'title'    => 'Location',
	 *             'taxonomy' => 'location'
	 *         )
	 *     )
	 * ) );
	 *
	 * That's all you need to do. The columns will handle all the sorting and safely outputting the data
	 * (escaping text, and comma-separating taxonomy terms). No more messing about with all of those
	 * annoyingly named column filters and actions.
	 *
	 * Each item in the 'cols' array should contain:
	 *
 	 * - A 'title' element containing the column title.
 	 * - One of the following elements which defines which type of column it is:
   	 *     - taxonomy - The name of a taxonomy
   	 *     - meta_key - A post meta key
   	 *     - post_field - The name of a post field (eg. post_excerpt)
	 *     - featured_image - A featured image size (eg. thumbnail)
	 *     - connection - A connection ID registered with the Posts 2 Posts plugin
	 *
	 * The value for the corresponding taxonomy terms, post meta or post field are safely escaped and output
	 * into the column, and the values are used to provide the sortable functionality for the column. For
	 * featured images, the post's featured image of that size will be displayed if there is one.
	 *
	 * There are a few optional elements:
	 *
 	 * - function - The name of a callback function for the column (eg. 'my_function') which gets called
	 * instead of the built-in function for handling that column. Note that it's not passed any parameters,
	 * so it must use the global $post object.
	 *
 	 * - default - Specifies that the admin screen should be sorted by this column by default (instead of
	 * sorting by post date). Can be boolean true (which will be treated as 'asc'), or 'asc' or 'desc' to
	 * explicitly control the default order.
	 *
	 * - width & height - These are only used for the 'featured_image' column type and allow you to set an
	 * explicit width and/or height on the <img> tag. Handy for downsizing the image.
	 *
	 * - field & value - These are used for the 'connection' column type and allow you to specify a
	 * connection meta field and value from the fields argument of the connection type.
	 *
	 * - date_format - This is used with the 'meta_key' column type. The value of the meta field will be
	 * treated as a timestamp if this is present (Unix and MySQL timestamp formats are both supported in the
	 * meta value). Pass in boolean true to format the date according to the 'Date Format' setting or pass
	 * in a valid date formatting string (eg. 'd/m/Y H:i:s').
	 *
	 * - cap - A capability required in order for this column to be displayed to the current user. Defaults
	 * to null, meaning the column is shown to all users.
	 *
	 * - sortable - A boolean value which specifies whether the column should be sortable. Defaults to true.
	 *
	 * Remember, in addition to custom columns there are also columns built in to WordPress which you can
	 * use: 'comments', 'date', 'title' and 'author'. You can use these columns as the array value or as the
	 * array key with a string value to change the column title. You can also pass boolean false to remove
	 * the 'cb' or 'title' columns, which are otherwise kept regardless.
	 *
	 * @param array $cols Associative array of columns
	 * @return array Updated array of columns
	 */
	public function cols( array $cols ) {

		$new_cols = array();
		$keep = array(
			'cb', 'title'
		);

		# Add existing columns we want to keep:
		foreach ( $cols as $id => $title ) {
			if ( in_array( $id, $keep ) and !isset( $this->args['cols'][$id] ) ) {
				$new_cols[$id] = $title;
			}
		}

		# Add our custom columns:
		foreach ( array_filter( $this->args['cols'] ) as $id => $col ) {
			if ( is_string( $col ) and isset( $cols[$col] ) ) {
				$new_cols[$col] = $cols[$col];
			} else if ( is_string( $col ) and isset( $cols[$id] ) ) {
				$new_cols[$id] = $col;
			} else if ( 'author' === $col ) {
				# Automatic support for Co-Authors Plus plugin and special case for
				# displaying author column when the post type doesn't support 'author'
				if ( class_exists( 'coauthors_plus' ) ) {
					$k = 'coauthors';
				} else {
					$k = 'author';
				}
				$new_cols[$k] = __( 'Author' );
			} else if ( is_array( $col ) ) {
				if ( isset( $col['cap'] ) and !current_user_can( $col['cap'] ) ) {
					continue;
				}
				if ( isset( $col['connection'] ) and !function_exists( 'p2p_type' ) ) {
					continue;
				}
				if ( !isset( $col['title'] ) ) {
					$col['title'] = self::get_item_title( $col );
				}
				$new_cols[$id] = $col['title'];
			}
		}

		# Re-add any custom columns:
		$custom   = array_diff_key( $cols, $this->_cols );
		$new_cols = array_merge( $new_cols, $custom );

		return $new_cols;

	}

	/**
	 * Output the column data for our custom columns.
	 *
	 * @param string $col The column name
	 * @return null
	 */
	public function col( $col ) {

		# Shorthand:
		$c = $this->args['cols'];

		# We're only interested in our custom columns:
		$custom_cols = array_filter( array_keys( $c ) );

		if ( !in_array( $col, $custom_cols ) ) {
			return;
		}

		if ( isset( $c[$col]['post_cap'] ) and !current_user_can( $c[$col]['post_cap'], get_the_ID() ) ) {
			return;
		}

		if ( isset( $c[$col]['function'] ) ) {
			call_user_func( $c[$col]['function'] );
		} else if ( isset( $c[$col]['meta_key'] ) ) {
			$this->col_post_meta( $c[$col]['meta_key'], $c[$col] );
		} else if ( isset( $c[$col]['taxonomy'] ) ) {
			$this->col_taxonomy( $c[$col]['taxonomy'], $c[$col] );
		} else if ( isset( $c[$col]['post_field'] ) ) {
			$this->col_post_field( $c[$col]['post_field'], $c[$col] );
		} else if ( isset( $c[$col]['featured_image'] ) ) {
			$this->col_featured_image( $c[$col]['featured_image'], $c[$col] );
		} else if ( isset( $c[$col]['connection'] ) ) {
			$this->col_connection( $c[$col]['connection'], $c[$col] );
		}

	}

	/**
	 * Output column data for a post meta field.
	 *
	 * @param string $meta_key The post meta key
	 * @param array  $args     Optional array of arguments for this field
	 * @return null
	 */
	public function col_post_meta( $meta_key, array $args = null ) {

		$val = get_post_meta( get_the_ID(), $meta_key, true );

		switch ( true ) {

			case isset( $args['date_format'] ):

				if ( true === $args['date_format'] ) {
					$args['date_format'] = get_option( 'date_format' );
				}

				if ( empty( $val ) ) {
					echo '&#8212;';
				} else if ( is_numeric( $val ) ) {
					echo date( $args['date_format'], $val );
				} else {
					echo mysql2date( $args['date_format'], $val );
				}

				break;

			default:

				echo esc_html( $val );

				break;

		}

	}

	/**
	 * Output column data for a taxonomy's term names.
	 *
	 * @param string $taxonomy The taxonomy name
	 * @param array  $args     Optional array of arguments for this field
	 * @return null
	 */
	public function col_taxonomy( $taxonomy, array $args = null ) {

		global $post;

		$terms = wp_get_object_terms( get_the_ID(), $taxonomy );
		$tax   = get_taxonomy( $taxonomy );

		if ( is_wp_error( $terms ) ) {
			echo $terms->get_error_message();
			return;
		}

		if ( empty( $terms ) ) {
			echo '&#8212;';
			return;
		}

		$out = array();

		foreach ( $terms as $term ) {

			if ( isset( $args['link'] ) ) {

				switch ( $args['link'] ) {
					case 'view':
						if ( $tax->public ) {
							$out[] = sprintf( '<a href="%1$s">%2$s</a>', get_term_link( $term ), $term->name );
						} else {
							$out[] = $term->name;
						}
						break;
					case 'edit' :
						if ( current_user_can( $tax->cap->edit_terms ) ) {
							$out[] = sprintf( '<a href="%1$s">%2$s</a>', get_edit_term_link( $term, $taxonomy, $post->post_type ), $term->name );
						} else {
							$out[] = $term->name;
						}
						break;
					case 'list':
						$link = add_query_arg( array(
							'post_type' => $post->post_type,
							$taxonomy   => $term->slug
						), admin_url( 'edit.php' ) );
						$out[] = sprintf( '<a href="%1$s">%2$s</a>', $link, $term->name );
						break;
				}

			} else {

				$out[] = $term->name;

			}

		}

		echo implode( ', ', $out );

	}

	/**
	 * Output column data for a post field.
	 *
	 * @param string $field The post field
	 * @param array  $args  Optional array of arguments for this field
	 * @return null
	 */
	public function col_post_field( $field, array $args = null ) {

		global $post;

		switch ( $field ) {

			case 'post_date':
			case 'post_date_gmt':
				if ( '0000-00-00 00:00:00' != $post->$field ) {
					echo mysql2date( get_option( 'date_format' ), $post->$field );
				}
				break;

			case 'post_modified':
			case 'post_modified_gmt':
				echo mysql2date( get_option( 'date_format' ), $post->$field );
				break;

			case 'post_status':
				if ( $status = get_post_status_object( get_post_status( $post ) ) ) {
					echo $status->label;
				}
				break;

			case 'post_author':
				echo get_the_author();
				break;

			case 'post_title':
				echo get_the_title();
				break;

			case 'post_excerpt':
				echo get_the_excerpt();
				break;

			default:
				echo esc_html( get_post_field( $field, $post ) );
				break;

		}

	}

	/**
	 * Output column data for a post's featured image.
	 *
	 * @param string $image_size The image size
	 * @param array  $args       Optional array of 'width' and 'height' attributes for the image
	 * @return null
	 */
	public function col_featured_image( $image_size, array $args = null ) {

		if ( !function_exists( 'has_post_thumbnail' ) ) {
			return;
		}

		if ( isset( $args['width'] ) ) {
			$width = is_numeric( $args['width'] ) ? sprintf( '%dpx', $args['width']  ) : $args['width'];
		} else {
			$width = 'auto';
		}

		if ( isset( $args['height'] ) ) {
			$height = is_numeric( $args['height'] ) ? sprintf( '%dpx', $args['height']  ) : $args['height'];
		} else {
			$height = 'auto';
		}

		$image_atts = array(
			'style' => sprintf( 'width:%1$s;height:%2$s', $width, $height ),
			'title' => ''
		);

		if ( has_post_thumbnail() ) {
			the_post_thumbnail( $image_size, $image_atts );
		}

	}

	/**
	 * Output column data for a Posts 2 Posts connection.
	 *
	 * @param string $connection The ID of the connection type
	 * @param array  $args       Optional array of arguments for a given connection type
	 * @return null
	 */
	public function col_connection( $connection, array $args = null ) {

		global $post, $wp_query;

		if ( !function_exists( 'p2p_type' ) ) {
			return;
		}

		if ( !p2p_connection_exists( $connection ) ) {
			_e( 'Invalid connection type', 'extended-cpts' );
			return;
		}

		$_post = $post;
		$meta  = $out = array();
		$field = 'connected_' . $connection;

		if ( isset( $args['field'] ) and isset( $args['value'] ) ) {
			$meta = array(
				'connected_meta' => array(
					$args['field'] => $args['value']
				)
			);
			$field .= sanitize_title( '_' . $args['field'] . '_' . $args['value'] );
		}

		if ( !isset( $_post->$field ) ) {
			p2p_type( $connection )->each_connected( $wp_query, $meta, $field );
		}

		foreach ( $_post->$field as $post ) {

			setup_postdata( $post );

			$pto = get_post_type_object( $post->post_type );
			$pso = get_post_status_object( $post->post_status );

			if ( $pso->protected and !current_user_can( 'edit_post', $post->ID ) ) {
				continue;
			}
			if ( 'trash' == $post->post_status ) {
				continue;
			}

			if ( isset( $args['link'] ) ) {

				switch ( $args['link'] ) {
					case 'view':

						if ( $pto->public ) {
							if ( $pso->protected ) {
								$out[] = sprintf( '<a href="%1$s">%2$s</a>', add_query_arg( 'preview', 'true', get_permalink() ), get_the_title() );
							} else {
								$out[] = sprintf( '<a href="%1$s">%2$s</a>', get_permalink(), get_the_title() );
							}
						} else {
							$out[] = get_the_title();
						}

						break;
					case 'edit':
						if ( current_user_can( 'edit_post', $post->ID ) ) {
							$out[] = sprintf( '<a href="%1$s">%2$s</a>', get_edit_post_link(), get_the_title() );
						} else {
							$out[] = get_the_title();
						}
						break;
					case 'list':
						$link = add_query_arg( array_merge( array(
							'post_type'       => $_post->post_type,
							'connected_type'  => $connection,
							'connected_items' => $post->ID
						), $meta ), admin_url( 'edit.php' ) );
						$out[] = sprintf( '<a href="%1$s">%2$s</a>', $link, get_the_title() );
						break;
				}

			} else {

				$out[] = get_the_title();

			}

		}

		#wp_reset_postdata();
		$post = $_post;

		echo implode( ', ', $out );

	}

	/**
	 * Add our post type archive link to the nav menus screen.
	 *
	 * @param array  $posts     Array of post objects and pseudo-post objects to show on the screen
	 * @param array  $meta_box  The meta box arguments
	 * @param string $post_type The current post type in the context of the nav menus screen
	 * @return array Updated array of posts and pseudo-posts
	 */
	public function nav_menu_items( array $posts, array $meta_box, $post_type ) {

		global $_nav_menu_placeholder;

		$pto = $post_type['args'];
		$_nav_menu_placeholder = ( 0 > $_nav_menu_placeholder ) ? intval( $_nav_menu_placeholder ) - 1 : -1;

		# Add our 'All Posts' item to the beginning of the list:
		array_unshift( $posts, (object) array(
			'ID'           => 0,
			'object_id'    => $_nav_menu_placeholder,
			'post_content' => '',
			'post_excerpt' => '',
			'post_parent'  => 0,
			'post_type'    => 'nav_menu_item',
			'post_title'   => $pto->labels->name,
			'label'        => $pto->labels->all_items, # http://core.trac.wordpress.org/ticket/24840
			'type'         => 'custom',
			'url'          => get_post_type_archive_link( $this->cpt->post_type ),
		) );

		return $posts;

	}

	/**
	 * Removes the Quick Edit link from the post row actions.
	 *
	 * @param $actions array Array of post actions
	 * @return array Array of updated post actions
	 */
	public function remove_quick_edit_action( array $actions ) {

		if ( $this->cpt->post_type != self::get_current_post_type() ) {
			return $actions;
		}

		unset( $actions['inline'], $actions['inline hide-if-no-js'] );
		return $actions;

	}

	/**
	 * Removes the Quick Edit link from the bulk actions menu.
	 *
	 * @param $actions array Array of bulk actions
	 * @return array Array of updated bulk actions
	 */
	public function remove_quick_edit_menu( array $actions ) {

		if ( $this->cpt->post_type != self::get_current_post_type() ) {
			return $actions;
		}

		unset( $actions['edit'] );
		return $actions;

	}

	/**
	 * Logs the default columns so we don't remove any custom columns added by other plugins.
	 *
	 * @param array $cols The default columns for this post type screen
	 * @return array The default columns for this post type screen
	 */
	public function _log_default_cols( array $cols ) {

		return $this->_cols = $cols;

	}

	/**
	 * A non-localised version of _n()
	 *
	 * @param string $single The text that will be used if $number is 1
	 * @param string $plural The text that will be used if $number is not 1
	 * @param int $number The number to compare against to use either $single or $plural
	 * @return string Either $single or $plural text
	 */
	protected static function n( $single, $plural, $number ) {

		return ( 1 == $number ) ? $single : $plural;

	}

	/**
	 * Get a sensible title for the current item (usually the arguments array for a column)
	 * 
	 * @param  array  $item An array of arguments
	 * @return string       The item title
	 */
	protected static function get_item_title( array $item ) {

		if ( isset( $item['taxonomy'] ) ) {
			$tax = get_taxonomy( $item['taxonomy'] );
			if ( !empty( $tax->exclusive ) ) {
				$title = $tax->labels->singular_name;
			} else {
				$title = $tax->labels->name;
			}
		} else if ( isset( $item['post_field'] ) ) {
			$title = ucwords( trim( str_replace( array( 'post_', '_' ), ' ', $item['post_field'] ) ) );
		} else if ( isset( $item['meta_key'] ) ) {
			$title = ucwords( trim( str_replace( array( '_', '-' ), ' ', $item['meta_key'] ) ) );
		} else if ( isset( $item['connection'] ) and isset( $item['value'] ) ) {
			$title = ucwords( trim( str_replace( array( '_', '-' ), ' ', $item['value'] ) ) );
		} else if ( isset( $item['connection'] ) ) {
			$title = ucwords( trim( str_replace( array( '_', '-' ), ' ', $item['connection'] ) ) );
		} else {
			$title = '';
		}

		return $title;

	}

}
}
